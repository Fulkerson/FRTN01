%\documentclass{tufte-handout}
\documentclass{article}
\usepackage{amsmath,amsthm}
\usepackage{fontspec}
%\usepackage{unicode-math}
%\setmathfont{Palatino Linotype}
%\setmainfont{Palatino Linotype}
%\usepackage{minted}
%\usemintedstyle{bw}
\usepackage{hyperref}

%\input{vc.tex}

%\newtheorem{claim}{Claim}[section]
\title{Control of Batch Tank using Raspberry Pi \\ FRTN01 project - Group 20}
%\date{\GITDate,\\\small\GITAbrHash}
\date{}
\author{Johan Anderholm \\ Jonathan Kämpe \\ Mikael Sahlström \\ Mikael Nilsson}

\begin{document}
\maketitle
\newpage
\tableofcontents
\newpage
\section{Problem description}
% An introduction that states the problem that has been solved.

\section{Program structure}
% A section describing the main program structure, both from a class
% and and a real-time perspective. If possible illustrate this with some
% type of figure.
This project is designed as a two-tier client/server system \cite[p.~6]{clientserver} where none of the control processes need to be directly connected to the batch tank.

The server contains of a driver that communicates with the batch tank over a serial interface and the server part of the server that receives connections from clients and serves them with desired data and redirects control signals from clients to the driver which sends them to the batch tank. The communication between the server and its clients is done via the TCP/IP protocol which means that the clients can be located anywhere. In our tests we have had clients running on the same device as the server and on separate devices connected through a switch and TP-cable.

\subsubsection{Protocol Buffers}
The messages used to communicate between clients and the servers are
described using a interface description language called Protocol
buffers, or protobuf.

\subsection{Server}
The server is implemented using C++ in order to run well on the Raspberry Pi as
there is currently not any acceptable JVM with proper JIT available. It
also makes calling timing functions more appropriate for real time tanks
considerably easier. The server consists of the following classes:

\begin{description}
\item[IORegistry]
  This class is used as an interface against the batchtank server.
  Mutexes are used in order to make reading and writing to the process
  atomic operations.

\item[ConnectionThread]
  Whenever a connection is made to the server a \verb+ConnectionThread+
  is fired and given control over that particular connection. Each
  connection contains a main reading loop executing controller events.
  It is running as a detached thread.

\item[PeriodicTask]
  Executes a function on a strictly regular basis. Uses
  \verb+clock_nanosleep+  with \verb+TIMER_ABSTIME+ and
  \verb+CLOCK_MONOTONIC+ and should have a fairly high resolution.

\item[Sampler]
  Ran as periodic task to sample at specified intervals.
\end{description}

\subsubsection{Use scenario}
The server listens to a port specified in a \verb+.ini+ file. When a client
connects the connection is assigned a dedicated \verb+ConnectionThread+. 
Upon a register event recieved a \verb+PeriodicTask+ is fired together
with a sampler that samples and sends samples to the client at a regular
interval. The register message contains data such as period time and
what sensors to read.

The client may respond with control signal events which specify what
value should be set as well as to what output. It also contains the
reference value used for this control signal.

Setting and getting values from the batch process is protected by a
\verb+IORegistry+ however locking of the registry is external, i.e. it
contains a public mutex and does no locking on its own. This is done in
order to enable batching several gets and sets as single atomic
operations. The \verb+IORegistry+ also contains copies of reference
values as well as control signals for plotting use cases.


\subsection{Driver}
The driver for the communication over a serial port is written in the C language. It makes use of the Unix API for terminal I/O. The operative system's driver will map the serial device to a file descriptor, hence the reads and writes are done with standard C functions read(3), write(1), open(2) and close(2).  The serial connection has a speed of 115200 baud. 

The driver has a set and get function and a couple of enumerators specifying the sensor to set or to get. The driver supports all available sensors or motors of the batch tank; temperature, water level, in/out pump, mixer, cooler and heater.

The get function is blocking with a timeout of 1 second. Any kind of failure will make the functions return a negative number. Data is sent and received in chunks of 8 bits. The get function sends a byte asking the batch tank to send some information about a specific sensor or motor, it then blocks on the read function untill all bytes are read. The set function simply puts commands on the serial line. The bytes are processed in accordance to the source code that runs on the batch tank \cite[line 150-223]{kokare.c}. 

The driver will always parse the whole value into bytes and then send it to the batch tank. The batch tank only supports values between 0 and 255. The temperature and the water level sensors may gerenrate greater values than 255. This is all supported. The driver is not thread safe.
\subsection{PID client}

\subsection{Plot client}
The plot client, written in Python \cite{python}, is in itself a server/client system where the server is a client to the main server and the clients are web browsers running the Javascript plotting code. When started, a HTTP server will start serving a HTML and Javascript page which is to be run in a browser. This page will request new data to plot from the HTTP server which then requests data from the main server. The main server then sends data (such as water level, control signals and reference signals) to the HTTP server which parses it into JSON \cite{json} formatted data and sends it to the plot page. The data format is as follows:
\begin{verbatim}
{"Plot name": { "Curve name": [y value, ...], ... }, ... }
\end{verbatim}
The data will be received and parsed by Javascript code which will go through it step by step. First, it checks if a plot exists, if not it is created, and then if the curves exists in the plot, if not they are created, and then shifts in the y values onto the curve data. The curve data will initially contain 100 zeros onto which the curve data is shifted from the right. The same amount of data is shifted out from the left so that the curve always contains 100 data points. This will create an effect where the data flows from the right to the left smoothly.

\section{Control design}
% A section describing the control design aspects of the p\ref{kokare.c}. roject.
\begin{description}
\item[$m$] Building of color matrices
\item[$2^n$] For all color combinations
\item[$n^3$] Determinant calculation
\item[$n^2$] Matrix addition/subtraction
\end{description}


\section{Running the system}
% A section describing the user interface in the project including a short
% HowTo description on how to start and operate the program.

\section{Results}
% A section containing the results. In case the project is a control-oriented
% project this should include plots of measurement signals, reference sig-
% nal, and control signal. If the project is more of a real-time nature then
% this section could contain measurement results of different type.

\section{Conclusion}
% A conclusion section.\ref{kokare.c}. 

Since the degree of the polynomial is at maximum n, by using Claim~2.1 in \cite[p.~2-1]{alistair} we get the bounded probability of less than $\frac{n}{p}$ where p is a previously fixed prime number.

\newpage

\begin{thebibliography}{9}
\bibitem{clientserver}
Kusarige, V. (2006), \emph{Client/server technology}, Southern Connecticut State University.
\bibitem{json}
\url{http://www.json.org}
\bibitem{python}
\url{http://python.org}
\bibitem{alistair}
\url{http://www.cs.berkeley.edu/~sinclair/cs271/n2.pdf}
\bibitem{testset}
\url{https://piazza.com/class#fall2012/edan55/50}
\bibitem{kokare.c}
\url{cook/kokare.c} line 150-223
\end{thebibliography}

\end{document}
